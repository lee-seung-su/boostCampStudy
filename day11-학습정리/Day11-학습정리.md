# Day11-학습정리

멀티 쓰레딩, 프로세싱과 같은 동시에 발생하는 환경에서 공유 자원에 동시에 접근할 경우 다양한 문제점 발생가능. → 여러가지 상호배제 해결하기 위한 방법 필요

**세마포어(Semaphore)**

공유된 자원의 데이터 or 임계영역에 여러 process, thread의 접근 막음(동기화 대상 1개 이상)

자원에 대한 카운터 개념으로 자원 남으면 사용가능, 없으면 사용 불가

**뮤텍스(Mutex)**

공유된 자원의 데이터 or 임계영역에 하나의 process, thread의 접근 막음(동기화 대상 1개)

데이터에 대한 접근으로 데이터에 접근 or 접근 금지

binary semaphore

운영체제 커널,프레임워크,라이브러리에 의해서 제공된다(?)

**모니터(Monitor)**

mutex + Condition Variable(Queue라고한다) → 즉 자원 사용중이면 대기하고 이후 깨워준다

뮤텍스는 다른 프로세스간의 동기화에 사용되며, 모니터는 한 프로세스 내의 다른 쓰레드 내의 동기화에 사용된다.

프레임워크 라이브러리 자체로 제공 → 뮤텍스보다 가볍고, 빠르다

개념적으로 binary semaphore

**임계영역(Critical Section)**

여러 프로세스가 데이터를 공유하면서 수행할 때 각 프로세스에서 공유 데이터에 접근하는 프로그램 코드 부분

멀티 프로세서 스케줄링

[https://lipcoder.tistory.com/entry/2-5장-멀티프로세서-스케줄링](https://lipcoder.tistory.com/entry/2-5%EC%9E%A5-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)

타이머 내부동작

- 일종의 쓰레드 클래스
- 싱글 스레드? → delay발생?

## **우선순위큐(Priority Queue) = 힙(Heap)이용하여 구현**

- 우선순위의 개념을 큐에 도입한 자료구조
- 들어온 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력

ex) 우선순위 : 들어온시점 빠른 것 → 큐

ex) 우선순위 : 들어온 시점 늦은 것 → 스택

- 적용 : 운영체제에서 작업 스케쥴링, 네트워크 트래픽 제어

## **힙(Heap)**

- 완전이진트리 → 중간에 비어있는 요소 x
- 주로 배열로 구현
- max, min 빨리 찾는 자료구조 + 우선순위 큐를 위한 지료구조
- 중복 값 허용.
- 반정렬 상태(부모노드의 값이 자식노드보다 항상 크거나 작다)

## **프로세스(Process)**

- 실행중인 프로그램 (코드자체는 프로그램 x -> 메모리에 올라가서 한줄씩 명령어 fetch해와야 프로그램 동작한다)
- 스케줄링의 대상이 되는 작업과 같은 의미
- 디스크의 프로그램 실행 → 실행을 위해 메모리 할당이 이루어지고 할당된 메모리로 바이너리 코드가 올라감. 이순간부터 os가 관리하는 프로세스라 불린다
- 프로세스당 1개의 메모리구조((code, data, stack, heap) -Day4 미션) 존재

## **프로세스 스케줄링**

- cpu는 1개지만 동시에 실행해야할 프로세스 여러개 → cpu가 고속으로 여러 프로세스 일정 기준으로 실행
- 스케줄링 : cpu할당 순서 정하는 방법

대부분의 OS에서는 우선순위 알고리즘, 라운드 로빈 알고리즘 혼합해서 사용

### **우선순위 알고리즘**

- 우선순위 큐를 사용하는 알고리즘

### **라운드로빈 알고리즘(Round-Robin)**

- 우선순위가 동일하면 누가 먼저 실행?

    최소 단위 시간(타임 슬라이스, 퀀텀)동안 실행하고 우선순위 동일한 프로세스에  cpu 전달

    퀀텀 짧으면 : 빈번한 context switching, 성능 저하

    퀀텀 길면 : 실시간 시스템에 문제

## **프로세스 상태변화**

크게 ready, blocked, running 상태 존재

**new → ready** : 프로세스 생성되면 OS커널내의 ready Queue에 올라간다

**ready → running** : 스케줄링 알고리즘에의해 running상태로 갈 프로세스 선택

**running → ready** : 실행하다가 높은 우선순위 프로세스 생성되면 cpu양도 or 다음순서의 프로세스로 cpu전달

**running → blocked** : 데이터 IO에 관한 일 하는 경우 다음 순서로 cpu양도 (IO event 발생할 때까지)

**blocked→ready** : IO event가 발생하면 해당 프로세스 다시 ready Queue에 올라간다

**running → terminated** : 프로세스 작업 끝나면 메모리에서 제거

new, terminated는 임시 상태

과제에서 말한 ready, running, waiting에서 waiting과 blocked는 같은 상태 의미

싱글코어에서는 running상태는 1개!!

## **쓰레드(Thread)**

- 실제로 상태변화 or 컴퓨터의 작업의 단위
- 즉 프로세스 내부의 작업의 단위
- 한 프로세스내부에 적어도 1개 존재
- 시스템 처리량 증가(처리 비용 감소) → code, data, heap공유로 stack정보만 주고받으면 된다
- 멀티쓰레드로 병렬 실행 가능

## **멀티쓰레드(MultiThread)**

- 각 쓰레드끼리는 프로세스의 일정 메모리 영역(code, data, heap) 공유. stack만 따로 할당 → context switching보다 훨씬 빠르다. 스위칭 할 메모리 영역 작아서

### **쓰레드 장점**

- 메모리 공유로 인한 시스템 자원 소모 감소
- 응답시간 단축
- context switching 오버헤드 감소

### 단점

- 서로 데이터 전달 시 충돌 발생가능
- 디버깅 까다롭다
