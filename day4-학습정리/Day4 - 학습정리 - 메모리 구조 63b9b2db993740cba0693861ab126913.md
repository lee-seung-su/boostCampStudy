# Day4 - 학습정리 - 메모리 구조

메모리구조

![Untitled](https://user-images.githubusercontent.com/52225690/126689298-24dae141-2d49-4e53-92ed-ca5510f8cc21.png)


64비트 운영체제에서는 High Address가 2^64 -1이 된다

**TEXT :** 프로그램 코드가 어셈블리어 형태로 들어간다

**GVAR** : 초기화 된 전역변수

**BSS** : 초기화 안된 전역변수

**Heap** : 동적할당 받은 변수 ex)malloc통해 할당된 변수

**Stack** : 지역변수, 함수, 등등 (stack자료구조가 사용된다)

 

**stack frame** : stack영역에 저장되는 함수 호출 정보

![Untitled 1](https://user-images.githubusercontent.com/52225690/126689295-08e30f8f-77fa-4c2b-9c6e-98aa5086e116.png)


**RET** : 함수 호출 이후에 돌아갈 주소가 저장

**RBP** : 이제 스택에 쌓을 것임을 알려주는 start bit같은거

이후 새로운 함수 호출하게되면 매개변수가 위에 쌓인다.

## **stack메모리** (높은주소 → 낮은주소)

**단점**

- 함수가 반환되는 순간 데이터가 다 사라진다 (지역변수 함수 안에서 유효)
- 차지할 크기 컴파일시에 결정해야한다
- 크기가 작다
- heap영역을 침범하면 **stack overflow**

데이터 수명 자유롭게 결정 + 용량제한없이 메모리 사용 필요

## **heap메모리 (낮은주소 → 높은주소)**

**장점**

- 용량제한 없음
- 함수 호출이 끝난다하여 사라지지 않음

**단점**

- 메모리 누수의 위험성 ex)c, c++는 따로 해제 필요
- stack에비해 할당, 해제 속도가 느리다
- stack영역 침범하면 heap overflow = out of memory

stack은 자료구조처럼 LIFO형태로 쌓여가지만 heap은 뭉텅이로 존재한다. 따라서 heap메모리를 관리하기위해서 stack에서 포인터를 이용해 heap 메모리를 관리한다

## **가비지 콜렉터 = 가비지 콜렉션 = GC**

- 더이상 사용되지 않는 동적 할당 메모리블럭을 자동으로 반환해주는 메모리 관리 기법

**원리 (Mark and Sweep)**

참조할 수 있는 방법이 없을 때 대상이 된다

이후 가비지 컬렉션시간에 해당 메모리 반환 > 이 시간에 가비지 컬렉션 제외한 대부분의 쓰레드 정지(stop the world타임)

**한계**

여전히 메모리 누수 발생가능 ex) 불필요한 참조

가비지 컬렉션시간으로 인한 성능하락 → 여러 최적화 기법 존재

## **Java 메모리 누수 방지 방법**

### 1. **JVM이용해 OS레벨의 메모리에 간접 접근**

C, C++은 OS레벨의 메모리에 직접 접근해야하므로 free()이용하여 메모리 명시적으로 해제 필요.

Java는 OS레벨의 메모리에 직접 접근 x → JVM이용해 간접 접근

즉 Java는 OS로부터 독립적 → OS레벨의 메모리 누수 불가능

### 2. **가비지 콜렉터**
