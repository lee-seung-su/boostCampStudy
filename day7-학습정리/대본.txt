안녕하십니까 안드로이드 신입부문에 지원한 이승수라고합니다
그럼 지금부터 객체 지향 프로그래밍에대해서 발표 시작하겠습니다
발표순서는 크게
프로그래밍 개발 스타일
OOP란
OOP의 4가지 특징 
SOLID 5원칙 순으로 발표 진행하겠습니다
우선 프로그래밍 개발스타일은 과거부터 현재까지 다음의 방식들이 사용되어 왔습니다.
그 방식으로는 
순차적 프로그래밍, 구조적,절차적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍이 있습니다.
하나씩 설명해보자면
우선 순차적 프로그래밍은 말그대로 순차적으로 진행되는 프로그래밍 방식입니다
따라서 딱히 구조라기보단 흐름에 가깝습니다.
순차적 프로그래밍방식으로 개발을 진행하다보면 코딩보단 작업 흐름을 더 많이 신경쓰게 됩니다.
예시로 장바구니 프로그램을 수도코드로 작성해보았습니다.
메인에서 사용자1이 장바구니에 물건을 추가하고 주문을 완료하고 주문금액을 확인하고있습니다.
그다음으로 사용자2도 장바구니에 물건을 추가하고 주문을 완료하고 주문금액을 확인하게됩니다.

해당코드를 보시면 물건추가, 주문완료, 주문금액 출력등의 코드가 많이 중복되는것을 볼 수있습니다.
따라서 순차적 프로그래밍방식으로 개발을 진행하던 개발자들은
 코드의 중복방지, 코드를 단위화할 방법을 모색하게 되었습니다. 

이에 절차적, 구조적 프로그래밍이 나오게되었습니다.
엄밀히말하면 절차적 프로그래밍방식과 구조적 프로그래밍방식은 차이점이 존재합니다
절차적 프로그래밍은 프로그램을 함수단위로 나눠서 진행하는 반면
구조적 프로그래밍은 프로그램을 모듈단위로 나눠서 진행하기 때문입니다.
하지만 함수와 모듈이 비슷한 기능단위로 구별된다는 점에서 유사하다고 판단하였습니다.
따라서 절차적, 구조적 프로그래밍방식은 함수단위로 진행되는 프로그램이라고 할 수 있습니다.
함수단위로 프로그램을 진행하면 이전의 코드의 중복을 대폭 줄일 수 있습니다.

이전의 장바구니 프로그램을 절차적 프로그래밍방식으로 바꿔보자면 다음과 같습니다.
장바구니넣기라는 함수가 존재하며 해당 함수는 사용자, 장바구니, 물건을 매개인자로 받게됩니다.
main문에서 사용자1,2 장바구니 1,2 물건 1,2,3을 선언하고
장바구니 넣기함수를 이용하여 각각의 사용자의 장바구니에 선택한 물건을 넣을 수 있습니다.
하지만 보시면 장바구니 넣기라는 기능과 장바구니, 사용자라는 변수가 분리되어 위치하는 것을 볼 수 있습니다.

이에 특정개념의 함수와, 자료형을 함께 묶어서 클래스로 관리하는 방식인 객체 지향 프로그래밍이 나오게되었습니다.
따라서 객체지향 프로그래밍은 특정 개념의 함수와 자료형을 함께 묶어서 클래스화 시킨 방식이며
객체 지향 프로그래밍에서 한 객체는 다른객체들로부터 독립적이며 이는 유지보수에 많은 도움을 줍니다.

장바구니를 클래스화 시켜보면 다음과같습니다
사용자, 주문금액이 변수로 존재하며
물건추가, 물건빼기라는 기능이 함수로써 존재합니다.
따라서 main에서 장바구니라는 인스턴스를 만들기만하면 자동으로 사용자와 장바구니가 mapping이 되며
장바구니1.물건추가(물건)이라는 방식으로 특정 사용자의 장바구니에 물건을 추가하고 현재 주문금액을 출력할 수 있습니다
하지만 객체지향 프로그래밍은 전역변수와 같은 외부 변수에 대해서는 독립성이 유지되지 않는다는 점이 있습니다.
또한 여러개의 쓰레드를 사용하는 경우 mutex와 semaphore를 이용한 코딩을 진행해야하고 이는 매우 까다롭고,
예측못한 변수를 발생시킬 수 있습니다

이에 요즘유행하는 함수형 프로그래밍방식이 나오게 되었습니다.
함수형 프로그래밍은 순수함수로만 프로그램을 수행하는 방식입니다.
여기서 순수함수란 주어진 입력에 대한 계산 이외의 다른 부수효과가 없는 함수를 의미합니다.
즉 순수함수를 이용한 프로그래밍에서는 항상 동일한 input에 대해서는 동일한 결과를 낸다는 특징이 있습니다.

다음으로 본격적으로 객체지향 프로그래밍에 대해서 설명을 드리겠습니다.
우선 오브젝트라는 개념이 있습니다. 이는 현실세계의 구현할 대상을 의미하며 현실세계의 자동차, 냉장고등이 그 예시라
할 수 있습니다
다음으로 클래스는 위의 오브젝트를 만들기위한 설계도라고 할 수 있습니다. 뒤에서 나올 추상화라는 개념을 통해서
클래스를 설계하게됩니다
다음으로 인스턴스는 위의 클래스를 바탕으로 프로그램에서 구현한 실체라고 할 수 있습니다.
즉 현실세계의 오브젝트를 프로그램에서 구현하기 위해 클래스를 설계하고, 이러한 클래스로부터 찍어낸 여러개의
인스턴스로 프로그래밍을 수행하는것을 객체지향프로그래밍 OOP라고 합니다.

이러한 객체지향프로그래밍에는 다음과 같이
추상화, 캡슐화, 상속, 다형성 이라는 4가지 특징이 존재합니다
우선 추상화부터 보자면 추상화는 간단히 현실세계의 오브젝트로부터 속성이나 기능을 추출하는 모델링 과정이라고 
할 수 있습니다. 예시로 중국집을 모델링해보자면 속성으로는 가게이름, 가게 전화번호, 메뉴판이 있을것이고
기능으로는 짜장면을 요리, 짬뽕을 요리가 있을 수 있습니다.

다음으로 캡슐화가 있습니다.
캡슐화란 연관된 변수, 함수를 클래스로 묶는 작업입니다.
클래스로 묶는 작업 뿐만아니라 접근제어자를 이용하여 은닉성이라는 성질도 가지고있습니다
접근제어자에 대해 잠시 짚고넘어가면
public, protected, private, default4가지가 존재합니다.
public은 프로그램안에서 항상 접근가능하고
protected는 상속받은 클래스와 자신 class에서만 접근이 가능하고
private은 자신 class에서만 접근이 가능하고
마지막으로 default는 해당 패키지 내에서만 접근이 가능합니다
접근제어자를 이용하여 예를 한번 준비해보았는데 
중국집_직원이라는 클래스가있고, 주방장은 중국집 직원이라는 클래스를 상속받은 형태입니다.
중국집 직원의 명찰은 중국집 직원이라면 누구나 접근할 수 있으므로 접근제어자가 protected로 선언하였으며
주방기기는 중국집 직원중에서 주방장만 접근이 가능해야하므로 private, 이름은 어디서나 불릴 수 있어야 하므로
public접근 제어자를 사용해 보았습니다.
따라서 이러한 접근제어자를 사용하여 사용자로부터 코드의 특정부분으로의 접근을 막을 수 있습니다

다음으로 상속과 다형성이 있습니다.
상속이란 기존 클래스로부터 특화된 버전의 클래스를 만드는 것이고
다형성이란 한가지 메서드나 객체를 상황에 맞게 다양하게 사용할 수 있게 해주는 것입니다
객체의 경우 다형성으로는 형변환이 있으며
메서드의 다형성으로는 오버라이딩과 오버로딩이 존재합니다

우선 다음의 예제 코드를 보시면
기존의 중국집_직원, 주방장 직원클래스 말고 중국집이라는 클래스가 추가되었습니다.
중국집 클래스는 직원목록 배열을 가지고있으며, 직원추가라는 메서드를 가지고 있습니다.

main에서 중국집 직원추가함수를 이용하여 중국집_직원1과 주방장을 추가해주었습니다.
중국집 직원을 인자로 받아야하지만 주방장이 자동으로 중국집 직원으로 형변환이 되는 다형성이 일어난것을 볼 수 있습니다
또한 중국집클래스의 직원list배열을 이용하여 각 직원의 자기소개를 진행하는 부분을 보면
중국집 직원의 자기소개함수와 주방장의 자기소개함수가 이름은 같지만 다르게 동작하는 것을 볼 수 있습니다
이와같이 부모클래스의 메서드를 자식클래스에서 변경하여 사용하는것을 메서드 오버라이딩이라하며
주방장클래스에는 자기소개 함수가 하나는 인사말을 인자로 받는 것이있고 다른 하나는 같은 자기소개함수이지만
인자가 없는 것을 볼 수 있습니다.
이를 main에서 수행한것을 보면 인자를 넣게되면 해당 인자를 포함하여 자기소개가 수행되는 것을 볼 수 있습니다.
이와같이 같은 함수이름을 가지고있지만 매기변수 타입이나, 갯수가 다른경우 상황에 맞는 함수가 수행되는 것을
메서드 오버로딩이라고 합니다.

마지막으로 SOLID5원칙에 대해 설명드리겠습니다
SOLID5원칙이란 객체 지향 프로그래밍을 잘 준수하기위한 원칙이라고 할 수 있습니다.
코드는 유연, 확장가능, 유지보수 용이, 재사용 가능해야한다는 개념에서 정의되었습니다
5원칙은 단일책임 원칙, 개발,폐쇄원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전원칙 이렇게 5가지로 구성되어있습니다
하나씩 살펴보자면
단일책임 원칙이란 객체는 1개의 책임을 가져야한다는 원칙입니다
예제로 살펴보자면
서점이라는 클래스는 서적판매만 하는 클래스입니다. 따라서 서적과 관련된 기능만 하는 클래스라고 할 수 있습니다.
하지만 만약 요리를 해주는 새로운 서점이라는 클래스가 생기게된다면 다음과같이 요리라는 interface를 상속받은 
형태일 것입니다. 하지만 이후 요리와 관련된 코드를 변경해야한다면 요리 interface를 상속받은 서점도 대대적인 
변경이 필요하게 될 것입니다. 따라서 각 객체는 관련된 기능으로만 구현되어야 한다는 것이 단일 책임 원칙입니다

다음으로는 개방/폐쇄 원칙과 리스코프 치환 원칙이 있습니다.
개방폐쇄 원칙이란 확장에는 열려있어야하고 변경에는 닫혀있어야한다를 의미하며
리스코프 치환 원칙이란 상위타입의 객체를 하위타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 
동작해야한다를 의미합니다.
예시 코드를 먼저보면 서점이라는 클래스가 있고 내부적으로 서적list와 서적 판매, 구매 함수가 있습니다.
또한 서적이라는 부모클래스가 있고, 잡지, 만화책이라는 클래스는 각각 서적이라는 클래스를 상속받은 형태입니다
이후 main에서 서점클래스의 서적구매함수에 잡지와, 만화책을 인자로 넘겨 서적구매함수를 호출하더라도 정상적으로
서적이 추가가 됩니다. 이는 자동으로 잡지 인스턴스와 만화책 인스턴스가 부모클래스인 서적 타입으로 형변환 되었기 때문입니다.
이와같이 상속은 허용 되지만 만화책 클래스를 변경시켜도 서점 클래스의 코드 변화는 최소한으로 하는것이
개방,폐쇄 원칙, 리스코프 치환원칙이라고 할 수 있습니다

다음으로 인터페이스 분리원칙은 인터페이스는 그 인터페이스를 사용하는 클라이언트 기준으로 분리해야한다
즉 인터페이스는 클라이언트에 특화되어야 한다는 말입니다
만약 서점에 주차장직원과, 서적정리 직원이 있고, 서점에서 필요한 기능이 서적정리, 주차정리 기능이라할때
주차장직원이 서적정리 기능을 수행할 필요는 없고, 마찬가지고 서적정리 직원도 주차정리 기능을 수행할 필요가 없습니다.
따라서 주차장 직원은 주차정리만을, 서적정리직원은 서적 정리만을 담당하는 인터페이스를 상속받아 구현하는것을
인터페이스 분리원칙이라고 합니다

마지막으로 의존성 역전원칙은 추상화 된것은 구체적인 것에 의존하면 안된다
즉 자신보다 변하기 쉬운것에 의존하지 말라는 원칙입니다.
예를들어 서점클래스에 직원정보를 인자로 받아 해당 직원의 정보를 출력하는 함수가 있다고할때
해당 함수를 주차장직원이나, 서적정리직원에 맞게 구현하게되면 이후 추가적으로 서적 구매직원이나, 서점 매니저가
추가되었을때 추가로 구현해줘야하는 불편함이 있습니다.
그렇기 때문에 인자로 직원이라는 추상화된 타입으로 받아 그 안에서 직원 타입에 맞게 함수를 수행하는 방식을 수행한다면 
추가적으로 다른 역할의 직원이 추가된다하더라도 변경이 필요없게하라는 원칙입니다.
 SOLID5원칙은 여러가지로 설명이 모호하거나 중복되는 개념이 많았는데 다시한번 정리하자면
단일책임원칙은 단일책임방식으로
인터페이스 분리원칙은 클라이언트마다 다른 인터페이스 구현으로 객체가 커지는 것을 막아주는 기능을 하고

개방,폐쇄 원칙은 기능확장을 할때 기존 코드변경이 최소한으로 이루어 지게하는 원칙이며
이를 의존성 역전 법칙이 변경되는 부분을 추상화 될수 있게
리스코프 치환 원칙이 다형성을 도와줌으로써 개방, 폐쇄 원칙이 잘 수행되도록 도와주는 원칙이라고 할 수 있습니다

이상으로 객체 지향 프로그래밍에 대한 발표를 마치겠습니다.
감사합니다