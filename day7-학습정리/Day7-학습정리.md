# Day7-학습정리

**클래스(Class)**

객체를 만들어 내기 위한 설계도

연관되어 있는 변수와 메서드의 집합

**객체(Object)**

구현할 대상

현실세계에 가깝다

**인스턴스(Instance)**

설계도를 바탕으로 구현한 구체적인 실체

소프트웨어세계에 가깝다

즉 객체를 만들기위해 클래스를 만들어서 클래스를 이용해 인스턴스를 찍어낸다

조금 더 덧붙이자면 클래스 타입으로 선언되었을때 : 객체 

객체가 메모리에 할당되어 실제 사용될 때 : 인스턴스

## **OOP(Object-Oriented Programming)-객체지향 프로그래밍**

- 프로그램을 어떻게 설계해야하는지에대한 **개념**이자 **방법론**
- 프로그램을 수많은 '객체'라는 기본단위로 나누고 객체간 상호작용으로 서술
- '객체'는 단순히 데이터 묶음 x / '역할'을 하는 메소드와 '데이터'의 묶음

**절차적 프로그래밍** 

- Input→Output 흐름 관점에서 프로그래밍

**구조적 프로그래밍** 

- 프로그램을 함수 단위로 나누고 함수간 호출하면서 프로그래밍
- 절차적 프로그래밍 개선 위함
- 프로그램 : 큰문제 → 해결하기위한 작은 문제로 나눠서 해결
- 따라서 Top-Down방식이라고 하기도 한다

**객체지향 프로그래밍** 

- 구조젝 프로그래밍 개선 위함
- 작은 문제 해결가능한 객체 → 큰 문제 해결
- Bottom-Up방식이라고 하기도 한다
- 객체는 한번 만들면 수없이 재사용가능 → 개발기간, 비용 대폭 감소

## [**4가지 특징]**

### **추상화**

클래스를 설계하는 데 있어 객체의 속성, 특징 뽑아내는 과정

즉 클래스 코드 만드는 과정

### **캡슐화 = 은닉화**

사용자에게 불필요한, 건드리면 위험한 코드 숨기는 작업 + 관련있는 변수, 함수 하나의 클래스로 묶는 작업

ex) getter, setter, 접근제어자

### **상속**

기존 클래스에서 더 특화된 버전의 클래스를 만들어내기 위함

ex) b class가 a class로부터 상속받으면 

a class : 부모클래스 / b class : 자식클래스

a class의 메서드, 변수는 모두 b에서 사용할 수 있다 + 커스터마이징 가능

*a class의 instance가 필요한 곳이면 언제든지 b_class사용가능

### **다형성**

한개의 메서드를 여러방법으로 구현하고 상황에따라 적당한 구현 선택하는 것

오버라이딩 + 오버로딩

**오버라이딩**

부모클래스의 메서드를 자식클래스에서 다르게 정의해서 사용하는 것

ex) a class{

fun func1(){

print("hello")

}

b class extends a{

fun func1(){

print("bye")

}

b.func1()하면 "bye"출력된다

**오버로딩**

인자의 갯수, 타입을 다르게 정의하는 것

ex)println()은 사실 여러 타입의 println() 오버로딩 한 것을 우리가 사용하는거다

![Untitled](https://user-images.githubusercontent.com/52225690/127208081-f9f07fae-cb01-4c08-8e8a-09e481f00d91.png)

## **5원칙(SOLID) - (OOP 방식 잘 준수하기 위한 원칙)**

"항상 코드는 유연 + 확장가능 + 유지보수 용이 + 재사용 가능 해야한다

**S(SRP : Single Responsibility Principle) -단일 책임 원칙**

한 클래스는 하나의 역할만 가져야 한다

**O(OCP : Open/Closed Principle) - 개방/폐쇄 원칙**

확장에는 열려있으나 변경에는 닫혀있어야한다

즉 상속은 가능 but 자식이 부모 변경은 불가

**L(LSP : Liskov's Substitution Principle) - 리스코프 치환 원칙**

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다

즉 자식 클래스는 항상 부모클래스 대체 가능 = downcasting(명시적으로 타입지정 필요)

 부모클래스 → 자식클래스로 형변환 = upcasting(타입지정 필요 x)→원본으로 되돌리기

**I(ISP : Interface Segregation Principle) -인터페이스 분리 원칙  ??**

특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 1개보다 낫다

즉 자신이 사용하지 않는 method는 구현하지 않아야한다.(?)

**D(DIP : Dependency Inversion Principle) - 의존성 역전 법칙  ??**

추상화에 의존한다. 구체화에 의존하면 안된다

즉 부모 클래스는 자식 클래스 의존하면 안된다(?)

**this** : 클래스 영역에서 정의한 변수, 메소드 or 현재 호출한 개체 참조하는 참조변수

**super** : 상속받은 클래스의 메소드, 변수 사용하는 키워드

### **data class**

- 데이터만을 담기위한 클래스
- 프로퍼티 자동 생성(getter, setter)→ 보일러 플레이트코드 삭제
- toString, equals 등 자동 오버라이딩

### **enum class**

- 연관된 상수들의 집합
- 정적변수의 상수가 많을 때 코드 가독성때문에 사용
- 타입 안정성이 보장된다

### **sealed class**

- 클래스들을 묶은 클래스 → 클래스 종류에 제약 받지 않는다
- enum클래스의 확장형태
- when표현식때문에 사용한다
- 특정 class들이 어떤 상위 클래스의 집합인지 명확히 알 수있다

[https://mparchive.tistory.com/193](https://mparchive.tistory.com/193)
